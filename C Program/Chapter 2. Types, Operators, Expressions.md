# Types, Operators, Expressions

- [Types, Operators, Expressions](#types-operators-expressions)
  - [2.1 Variable Names](#21-variable-names)
  - [2.2 Data Types and Sizes](#22-data-types-and-sizes)
  - [2.3 Constants](#23-constants)
  - [2.4 Declarations](#24-declarations)
  - [2.5 Arithmetic Opertors](#25-arithmetic-opertors)
  - [2.6 Relational and Logical Operators](#26-relational-and-logical-operators)
  - [2.7 Type Conversions](#27-type-conversions)
  - [2.8 Increment and Decrement Operators](#28-increment-and-decrement-operators)
  - [2.9 Bitwise Operators](#29-bitwise-operators)
  - [2.10 Assignment Operators and Expressions](#210-assignment-operators-and-expressions)
  - [2.11 Conditional Expressions](#211-conditional-expressions)
  - [2.12 Precedence and Order Evaluation](#212-precedence-and-order-evaluation)

变量和常量是程序处理的两种基本数据对象。

声明语句：说明变量的名字及类型，也可以指定变量的初值。
运算符：指定将要进行的操作。表达式则把变量与常量组合起来生成新的值。
对象的类型：决定该对象可取值的集合以及可以对该对象执行的操作。

## 2.1 Variable Names

- 名字是由字母和数字组成的序列，但其第一个字符必须为字母。
- 下划线“_”被看做是字母，通常用于命名较长的变量名，以提高其可读性。由于例程的名字通常以下划线开头，因此变量名不要以下划线开头。
- 大写字母与小写字母是有区别的，所以，x 与 X 是两个不同的名字。在传统的 C 语言用法中，**变量名使用小写字母**，**符号常量名全部使用大写字母**。
- 类似于 if、else、int、float 等关键字是保留给语言本身使用的，不能把它们用做变量名。所有关健字中的字符都必须小写
- 局部变量一般使用较短的变量名（尤其是循环控制变量），外部变量使用较长的名字。

***

## 2.2 Data Types and Sizes

C 语言只提供了下列几种**基本数据类型**:

- char 字符型，占用一个字节，可以存放本地字符集中的一个字符
- int 整型，通常反映了所用机器中整数的最自然长度
- float 单精度浮点型
- double 双精度浮点型

**整型限定符:** short、long

```c
/* 上述两种类型声明中，关键字int可以省略*/
short int sh;
long int counter;
```

short 类型通常为 16 位，1ong 类型通常为 32位，int 类型可以为 16 位或 32 位。

各编译器可以根据硬件特性自主选择合适的类型长度，但要遵循下列限制：short 与 int 类型至少为 16 位，而 long 类型至少为 32 位，并且 short 类型不得长于 int 类型，而 int 类型不得长于 long 类型。

**类型限定符:** signed 和 unsigned 可用于限定 char 类型或任何整型。

unsigned 类型的数总是正值或 0，并遵守算术模 ${2^n}$ 定律，其中 n 是该类型占用的位数。

例如，如果 char 对象占用 8 位，那么 unsigned char 类型变量的取值范围为 0～255，而 signed char 类型变量的取值范围则为-128～127（在采用对二的补码的机器上）。不带限定符的 char 类型对象是否带符号则取决于具体机器，但可打印字符总是正值。

**long double 类型表示高精度的浮点数。** 同整型一样，浮点型的长度也取决于具体的实现。float、double 与 long double 类型可以表示相同的长度，也可以表示两种或三种不同的长度。

***

## 2.3 Constants

**整数常量**：

- 类似于 1234 的整数常量属于 int 类型。如果一个整数太大以至于无法用 int 类型表示时，也将被当作 long 类型处理。
- long 类型的常量以字母 l 或 L 结尾，如123456789L。
- 无符号常量以字母 u 或 U 结尾。后缀 ul 或 UL 表明是 unsigned long 类型。

**浮点数常量**:

- 包含一个小数点（如 123.4）或一个指数（如 1e-2），也可以两者都有。
- 没有后缀的浮点数常量为 double 类型。
- 后缀 f 或 F 表示 float 类型。
- 后缀 l 或 L 则表示 long double 类型。

**八进制与十六进制整型常量**:

- 带前缀 0 的整型常量表示它为八进制形式；
- 前缀为 0x 或 0X，则表示它为十六进制形式。
- 八进制与十六进制的常量也可以使用后缀 L 表示 long 类型，使用后缀 U 表示 unsigned 类型。

**字符常量**:

- 一个字符常量是一个整数，书写时将一个字符括在单引号中，如，'x'。字符在机器字符集中的数值就是字符常量的值。
- 字符常量一般用来与其它字符进行比较，但也可以像其它整数一样参与数值运算

**字符常量-转义字符**:

- 某些字符可以通过转义字符序列（例如，换行符\n）表示为字符和字符串常量。转义字符序列看起来像两个字符，但只表示一个字符。
- ‘\ooo’表示ascii码为八进制数ooo的字符，如’\101’代表ascii码为65的字符’A’
- ‘\xhh’表示ascii码为十六进制数oo的字符，如’\xff’代表ascii码为255的扩展字符
- 举例如下:

```c
/* \ooo */
#define VTAB '\013' /* ASCII vertical tab */
#define BELL '\007' /* ASCII bell character */
/* \xhh */
#define VTAB '\xb' /* ASCII vertical tab */
#define BELL '\x7' /* ASCII bell character */
```

**ANSI C 语言中的全部转义字符序列如下所示：**

```shell
\a 响铃符 \\ 反斜杠
\b 回退符 \? 问号
\f 换页符 \' 单引号
\n 换行符 \" 双引号
\r 回车符 \ooo 八进制数
\t 横向制表符 \xhh 十六进制数
\v 纵向制表符
```

字符常量'\0'表示值为 0 的字符，也就是空字符（null）。我们通常用'\0'的形式代替 0，以强调某些表达式的字符属性，但其数字值为 0。

**常量表达式**：

常量表达式是**仅仅只包含常量的表达式**。这种表达式在编译时求值，而不在运行时求值。它可以出现在常量可以出现的任何位置，例如：

```c
#define MAXLINE 1000
char line[MAXLINE+1];

#define LEAP 1 /* in leap years */
int days[31+28+LEAP+31+30+31+30+31+31+30+31+30+31];
```

**字符串常量**:也叫字符串字面值，是用双引号括起来的 0 个或多个字符组成的字符序列。

```c
"I am a string"

"" /* 空字符串 */
```

- 双引号不是字符串的一部分，它只用于限定字符串。
- 当字符串常量中需要包含双引号时，使用转移字符 \",而`"hello," " world"`等价于`"hello, world"`
- 从技术角度看，**字符串常量就是字符数组**。字符串的内部表示使用一个空字符'\0'作为串的结尾，因此。存储字符串的物理存储单元数比括在双引号中的字符数多一个。C 语言对字符串的长度没有限制，但程序必须扫描完整个字符串后才能确定字符串的长度。

**注意:** 搞清楚字符常量与仅包含一个字符的字符串之间的区别：'x'与"x"是不同的。

**枚举常量:**

- 枚举是一个常量整型值的列表，例如：

```c
enum boolean { NO, YES };
```

- 在没有显式说明的情况下，enum 类型中第一个枚举名的值为 0，第二个为 1，依此类推。
- 如果只指定了部分枚举名的值，那么未指定值的枚举名的值将依着最后一个指定值向后递增，参看下面两个例子中的第二个例子

```c
enum escapes { BELL = '\a', BACKSPACE = '\b', TAB = '\t',
               NEWLINE = '\n', VTAB = '\v', RETURN = '\r' 
            };

enum months { 
    JAN = 1, FEB, MAR, APR, MAY, JUN,
    JUL, AUG, SEP, OCT, NOV, DEC 
    
    };
/* FEB 的值为 2，MAR 的值为 3，依此类推 */
```

- 不同枚举中的名字必须互不相同。同一枚举中不同的名字可以具有相同的值

**枚举与#define语句：**

- 枚举为建立常量值与名字之间的关联提供了一种便利的方式。相对于#define 语句来说，它的优势在于常量值可以自动生成。

***

## 2.4 Declarations

**所有变量都必须先声明后使用**，一个声明指定一种变量类型，**后面所带的变量表可以包含一个或多个该类型的变量。**

```c
int lower, upper, step;
char c, 1ine[1000];
```

还可以在**声明的同时对变量进行初始化**。在声明中，如果变量名的后面紧跟一个等号以
及一个表达式，该表达式就充当对变量进行初始化的初始化表达式。

```c
char esc = '\\';
int i = 0;
int limit = MAXLINE + 1;
float eps = 1.0e-5;
```

如果变量**不是自动变量**，**则只能进行一次初始化操作**，而显式初始化的自动变量每次进入函数或程序块时，都将被初始化一次，其初始化表达式可以是任何表达式。

默认情况下，外部变量与静态变量将被初始化为 0。未经显式初始化的自动变量的值为未定义值（即无效值）。

**任何变量的声明都可以使用 const 限定符限定。** 该限定符指定变量的值不能被修改。对数组而言，const 限定符指定数组所有元素的值都不能被修改：

```c
const double e = 2.71828182845905;
const char msg[] = "warning: ";
```

const 限定符也可配合数组参数使用，它表明函数不能修改数组元素的值,如果试图修改const 限定符限定的值，其结果取决于具体的实现。

```c
int strlen(const char[]);
```

***

## 2.5 Arithmetic Opertors

二元算术运算符包括：+、-、*、/、%（取模运算符）。

- 整数除法会截断结果中的小数部分。
- 取模运算符%不能应用于 float 或 double 类型。

***

## 2.6 Relational and Logical Operators

关系运算符包括下列几个运算符：`> >= < <=`

逻辑运算符&&与||有一些较为特殊的属性，由&&与||连接的表达式按从左到右的顺序进
行求值，并且，在知道结果值为真或假后立即停止计算。

逻辑非运算符!的作用是将非 0 操作数转换为 0，将操作数 0 转换为 1。

***

## 2.7 Type Conversions

当一个运算符的几个操作数类型不同时，就需要通过一些规则把它们转换为某种共同的类型.

- 自动转换是指把“比较窄的”操作数转换为“比较宽的”操作数，并且不丢失信息的转换
- 不允许使用无意义的表达式，例如，不允许把 float 类型的表达式作为下标。

**1. char类型变量类型转换举例**

```c
/* atoi: convert s to integer */
int atoi(char s[])
{
    int i, n;
    n = 0;
    for (i = 0; s[i] >= '0' && s[i] <= '9'; ++i)
        n = 10 * n + (s[i] - '0');
    return n;
}
```

```c
/* lower: convert c to lower case; ASCII only */
int lower(int c)
{
    if (c >= 'A' && c <= 'Z')
        return c + 'a' - 'A';
    else
        return c;
}
```

**注意:**。C 语言没有指定 char 类型的变量是无符号变量（signed）还是带符号变量（unsigned）。当把一个 char 类型的值转换为 int 类型的值时，其结果有没有可能为负整数？**对于不同的机器，其结果也不同，这反映了不同机器结构之间的区别。**

当表达式中**没有 unsigned类型的操作数时**，使用如下规则:

- 如果其中一个操作数的类型为 long double，则将另一个操作数转换为 1ong double 类型;
- 如果其中一个操作数的类型为 double，则将另一个操作数转换为 double 类型；
- 如果其中一个操作数的类型为 float，则将另一个操作数转换为 float 类型；
- 将 char 与 short 类型的操作数转换为 int 类型；
- 如果其中一个操作数的类型为 long，则将另一个操作数也转换为 long 类型。

**注意:** float 类型的操作数不会自动转换为 double 类型。一般来说，数学函数（如标准头文件<math.h>中定义的函数）使用双精度类型的变量。使用 float 类型主要是为了在使用较大的数组时节省存储空间，有时也为了节省机器执行时间（双精度算术运算特别费时）。

当表达式中**包含 unsigned 类型的操作数时**，转换规则要复杂一些:

- **主要原因**在于，带符号值与无符号值之间的比较运算是与机器相关的，因为它们取决于机器中不同整数类型的大小。例如，假定 int 类型占 16 位，long 类型占 32 位，那么，-1L < 1U，这是因为 unsighed int 类型的 1U 将被提升为 signed long 类型；但-1L > 1UL，这是因为 1L 将被提升为 unsigned long 类型，因而成为一个比较大的正数。

- 赋值时也要进行类型转换。赋值运算符右边的值需要转换为左边变量的类型，左边变量的类型即赋值表达式结果的类型。
  - 前面提到过，无论是否进行符号扩展，字符型变量都将被转换为整型变量。当把较长的整数转换为较短的整数或 char 类型时，超出的高位部分将被丢弃。
  - 如果 x 是 float 类型，i 是 int 类型，那么语句 x = i 与 i = x 在执行时都要进行类型转换。当把 float 类型转换为 int 类型时，小数部分将被截取掉；
  - 当把 double 类型转换为 float 类型时，是进行四舍五入还是截取取决于具体的实现。
- 由于函数调用的参数是表达式，所以在把参数传递给函数时也可能进行类型转换。
  - 在没有函数原型的情况下，char 与 short 类型都将被转换为 int 类型，float 类型将被转换为double 类型。
  - 因此，即使调用函数的参数为 char 或 float 类型，我们也把函数参数声明为 int 或 double 类型。

**强制类型转换：** 在任何表达式中都可以使用一个称为强制类型转换的一元运算符强制进行显式类型转换。

`(类型名) 表达式`

在上述语句中，表达式首先被赋值给类型名指定的类型的某个变量，然后再用该变量替换上述整条语句。

***

## 2.8 Increment and Decrement Operators

C 语言提供了两个用于变量递增与递减的特殊运算符。自增运算符++使其操作数递增 1，自减运算符使其操作数递减 1。

表达式++n 先将 n 的值递增 1，然后再使用变量 n 的值，而表达式 n++则是先使用变量 n 的值，然后再将 n 的值递增 1。

***

## 2.9 Bitwise Operators

C 语言提供了 6 个位操作运算符。这些运算符只能作用于整型操作数，即只能作用于带符号或无符号 char、short、int、long 类型：

```c
&  // 按位与（AND）
|  // 按位或（OR）
^  // 按位异或（XOR）
<< // 左移
>> // 右移
~  // 按位求反（一元运算符）
```

**按位运算符功能:**

- 按位与运算符&经常用于屏蔽某些二进制位，例如：`n = n & 0177`,该语句将 n 中除 7 个低二进制位外的其它各位均置为 0。
- 按位或运算符|常用于将某些二进制位置为 1，例如：`x = x | SET_ON；`,该语句将 x 中对应于 SET_ON 中为 1 的那些二进制位置为 1。
- 按位异或运算符^**当两个操作数的对应位不相同时将该位设置为 1**，否则，将该位设置为0。
- **注意:**区分按位运算符与逻辑运算符的区别

**移位运算符:**

移位运算符<<与>>分别用于将运算的左操作数左移与右移，移动的位数则由右操作数指
定（右操作数的值必须是非负值）。左移一位乘以2，右移一位除以2

- 在对 unsigned 类型的无符号值进行右移位时，左边空出的部分将用 0 填补；
- 当对 signed 类型的带符号值进行右移时，某些机器将对左边空出的部分用符号位填补（即“算术移位”），而另一些机器则对左边空出的部分用 0填补（即“逻辑移位”）。

**一元运算符:**
一元运算符~用于求整数的二进制反码，即分别将操作数各二进制位上的 1 变为 0，0 变
为 1。

举例：

```c
/* getbits: get n bits from position p
    它返回 x 中从右边数第 p 位开始向右数 n 位的字段。
 */
unsigned getbits(unsigned x, int p, int n)
{
    return (x >> (p+1-n)) & ~(~0 << n);
}
```

表达式 m << (p+1-n)将期望获得的字段移位到字的最右端。~0 的所有位都为 1，这里使用语句~0 << n 将~0 左移 n 位，并将最右边的 n 位用 0 填补。再使用~运算对它按位取反，这样就建立了最右边 n 位全为 1 的屏蔽码。

***

## 2.10 Assignment Operators and Expressions

大多数二元运算符（即有左、右两个操作数的运算符，比如+）都有一个相应的赋值运算
符 op=，其中，op 可以是下面这些运算符之一：

```c
+ - * / % << >> & ^ |
```

如果 expr1 和 expr2 是表达式，那么 `expr1 op= expr2` 等价于 `expr1 = (expr1) op (expr2)`
它们的区别在于，前一种形式 expr1 只计算一次。注意，在第二种形式中，expr2 两边的圆括号是必不可少的，例如，`x *= y + 1`的含义是：`x = x * (y + 1)` 而不是`x = x * y`

**优点:**

- 简洁
- 表示方式与人们的思维习惯比较接近。 i += 2 表示把2 加到 i上
- 赋值运算符使程序代码更易于理解，阅读者不用检查两侧表达式是否一致
- 赋值运算符还有助于编译器产生高效代码。

***

## 2.11 Conditional Expressions

条件表达式（使用三元运算符“? :”）提供了另外一种方法编写这段程序及类似的代码段，在表达式：

```c
expr1 ? expr2 : expr3
```

- 首先计算 expr1，**如果其值不等于 0（为真**），则计算 **expr2** 的值，并以该值作为条件表达式的值，否则计算 expr3 的值，并以该值作为条件表达式的值。
- expr2 与 expr3 中只能有一个表达式被计算。
- 如果 expr2 与 expr3 的类型不同，结果的类型将由本章前面讨论的转换规则决定。
例如，如果 f 为 float 类型，n 为 int 类型，那么表达式`(n > 0) ? f : n`是 float 类型，与 n 是否为正值无关。

***

## 2.12 Precedence and Order Evaluation

运算符优先级与结合性

|   运算符    |    结合性   |
|   ----     |    ----    |
|   () [] -> .     |    从左至右    |
|   ! ~ ++ -- + - * (type) sizeof     |    从右至左    |
|   * / %     |    从左至右    |
|   + -     |    从左至右    |
|   << >>     |    从左至右    |
|   < <= > >=     |    从左至右    |
|  == !=     |    从左至右    |
|   &     |    从左至右    |
|   ^     |    从左至右    |
|   |     |    从左至右    |
|   &&     |    从左至右    |
|   ||     |    从左至右    |
|   ?:     |    从左至右    |
|   = += -= *= /= %= &= ^= |= <<= >>=     |    从右至左    |
|   ,     |    从右至左    |

注意:

- 一元运算符+、-、&与*比相应的二元运算符+、-、&与*的优先级高。
- 位运算符&、^与|的优先级比运算符==与!=的低。这意味着，位测试表达式，如if ((x & MASK) == 0) ...必须用圆括号括起来才能得到正确结果。
- C 语言没有指定同一运算符中多个操作数的计算顺序（&&、||、?:和,运算符除外）
- C 语言也没有指定函数各参数的求值顺序。因此，下列语句`printf("%d %d\n", ++n, power(2, n)); /* 错 */`在不同的编译器中可能会产生不同的结果.这取决于 n 的自增运算在 power 调用之前还是之后执行。解决的办法是把该语句改写成下列形式：

```c
++n;
printf("%d %d\n", n, power(2, n));
```

- 函数调用、嵌套赋值语句、自增与自减运算符都有可能产生“副作用”——在对表达式
求值的同时，修改了某些变量的值。下列语句就是一个典型的令人不愉快的情况：`a[i] = i++;`问题是：数组下标 i 是引用旧值还是引用新值？对这种情况编译器的解释可能不同，并因此产生不同的结果
