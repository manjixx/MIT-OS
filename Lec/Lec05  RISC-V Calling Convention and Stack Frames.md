# Lec05  RISC-V Calling Convention and Stack Frames

## 一、课程内容

1. syscall lab?
2. C -> ASM/Processor
3. RISC-V & X86
4. Register
5. Stack + Calling Conventions
6. Struct Layout in Memory

## 二、C -> ASM and Processor

RISC-V实际是指 RISC-V指令集

C -> ASM(.S files) -> Binary(obj/.o) 

上述流程适用于任何编译语言

## 三、RISC-V & X86

有很多不同类型的汇编，本书用的最多的是RISC-V(精简指令集)

大多数现代计算机都运行在x86和x86-64处理器上。x86(复杂指令集)拥有一套不同的指令集，看起来与RISC-V非常相似。通常你们的个人电脑上运行的处理器是x86，Intel和AMD的CPU都实现了x86。

RISC-V中的RISC是精简指令集（Reduced Instruction Set Computer）的意思，而x86通常被称为CISC，复杂指令集（Complex Instruction Set Computer）。这两者之间有一些关键的区别：

- 指令数量
  - X86：
    - 3 full books
    - 3 instructs/ month
  - RISC-V
    - fewer inst
    - simple instr
    - open source

ARM(RISC)

- 高通的Snapdragon处理器就是基于ARM
- 苹果公司也实现某种版本的ARM处理器，这些处理器运行在iPad，iPhone和大多数苹果移动设备上，甚至对于Mac，苹果公司也在尝试向ARM做迁移（注，刚刚发布的Macbook）

RISC-V 除了Qumu可以再很多即成设备中寻找

学生提问：为什么x86会有15000条指令？
TA：如我刚刚说的，我们需要许多指令来实现向后兼容，向后兼容是否重要因人而异。另一方面，我认为这里许多指令都是cmd指令，用来完成一些特殊的操作。我从来没有见过一个Intel的汇编代码使用了所有的15000个指令。大多数这些指令都是为了向后兼容和cmd的需求创建。

如果查看RISC-V的文档，可以发现RISC-V的特殊之处在于：

- 它区分了Base Integer Instruction Set和Standard Extension Instruction Set。
- Base Integer Instruction Set包含了所有的常用指令，比如add，mult。
- 处理器还可以选择性的支持Standard Extension Instruction Set。例如，一个处理器可以选择支持Standard Extension for Single-Precision Float-Point。这种模式使得RISC-V更容易支持向后兼容。 每一个RISC-V处理器可以声明支持了哪些扩展指令集，然后编译器可以根据支持的指令集来编译代码。

## 四、汇编代码与GDB

```s
.section .text
.global sum_to

/**
    int sum_to(int n){
        int acc = 0;
        for(int i = 0; i <= n; i++){
            acc += i;
        }
        return acc;
    }
*/

sum_to:
    mv to, a0       # t0 <- a0
    li a0, 0        # a0 <- 0
  loop:
    add a0, a0, t0  # a0 <- a0 + t0
    addi t0, t0, -1 # t0 <- t0 - 1
    bnez t0, loop   # if t0 != 0 : pc <- loop
    ret
```

编译后查看 kenel/kernel.asm

学生提问：.asm文件和.s文件有什么区别？
TA：我并不是百分百确定。这两类文件都是汇编代码，.asm文件中包含大量额外的标注，而.s文件中没有。所以通常来说当你编译你的C代码，你得到的是.s文件。如果你好奇我们是如何得到.asm文件，makefile里面包含了具体的步骤。

如何在gdb中调试

- 两个窗口
  - 启动QEMU在gdb模式下启动
  - 启动gdb
- tui enable
- 设置一个断点 b sum_to
- c
- 在 tui 窗口中
  - 查看汇编文件 layout asm
  - 查看寄存器 layout reg
  - 选择汇编文件窗口 focus asm
  - 选择寄存器窗口 focus reg
  - 查看源码c窗口与汇编窗口 layout split
  - 仅查看源码c窗口 layout src
  - 查看栈帧信息 i frame
  - 查看函数参数相关信息 i args/ backtrace/bt
  - 查看栈帧中的详细信息`frame + 栈帧号`
  - 查看某个地址中存放的内容`p 指针/地址` 
    - p *argv@2 加长度
    - p *argv@argc
- 单步执行 si，按下entry将会继续单步执行
- 查看断点信息 info break 或者 info breakpoints
- 不使用窗口而查看reg信息
  - info reg
  - info registers
  - i registers
- 删除所有断点 delete
- watch sum
- i locals
- b sum_to if i == 5
- gdb内置手册 apropos tui，显示所有相关的tui命令

如何打开多个窗口，使用tmux

## 四、Register

汇编在寄存器上操作

load value -> reg

Caller Saved寄存器在函数调用的时候不会保存,寄存器可以被被调用函数重写
Callee Saved寄存器在函数调用的时候会保存

## 五、Stack

stack frame generated by function call

栈总是向下扩展，即从高地址到低地址

栈帧大小不一定相同

栈顶端一定是返回地址

sp bottom of stack
fp top of current frame

汇编中的叶子函数

非叶子函数

```s
.global sum_then_double
sum_then_double:
    addi sp, sp, -16;
    ad ra, 0(sp)
    call sum_to
    li to, 2
    mul a0, a0, t0
    ld ra, 0(sp)
    addi sp, sp, 16
    ret
```

## 六、 struct layout in mermory

